if [ -f /etc/bash_completion ]; then
    source /etc/bash_completion
fi

if tput setaf 1 &> /dev/null; then
    tput sgr0; # reset colors
    bold=$(tput bold);
    reset=$(tput sgr0);
    black=$(tput setaf 0);
    blue=$(tput setaf 33);
    cyan=$(tput setaf 37);
    green=$(tput setaf 64);
    orange=$(tput setaf 166);
    purple=$(tput setaf 125);
    red=$(tput setaf 124);
    violet=$(tput setaf 61);
    white=$(tput setaf 15);
    yellow=$(tput setaf 136);
else
    bold='';
    reset="\e[0m";
    black="\e[1;30m";
    blue="\e[1;34m";
    cyan="\e[1;36m";
    green="\e[1;32m";
    orange="\e[1;33m";
    purple="\e[1;35m";
    red="\e[1;31m";
    violet="\e[1;35m";
    white="\e[1;37m";
    yellow="\e[1;33m";
fi;

function git_info() {
    # check if we're in a git repo
    git rev-parse --is-inside-work-tree &>/dev/null || return

    # quickest check for what branch we're on
    branch=$(git symbolic-ref -q HEAD | sed -e 's|^refs/heads/||')

    # check if it's dirty (via github.com/sindresorhus/pure)
    changes=":$(git status -s | wc -l | tr -d ' ')"

    echo $black"on "$orange$branch$purple$changes
}

default_user='phil'
if [ $USER != "$default_user" ]; then
    usercolor=$red;
else
    usercolor=$cyan;
fi

# Nicely formatted terminal prompt 
export PS1='\n\[$bold\]\[$black\]\[$usercolor\]\u \[$black\]at \[$usercolor\]\h \[$black\]in \[$yellow\]\w $(git_info)\[$black\]\[$reset\]\n\[$black\]âžœ\[$reset\] '
